{"id":"EXAMOD_RM","name":"ExAMod_RepeatedMessages","options":[],"trigger":"MESSAGE_CREATE","components":[{"type":"ACTION","action":{"type":"EXECUTE_CODE","execute_code":{"code":"// ExAMod by rovius\n// https://github.com/rovius/ExAMod\n// Repeated messages filter\n\n// Define your configuration (replace with actual values)\nconst config = {\n    ignoredChannels: ['channelID1', 'channelID2'],\n    ignoredMembers: ['userID1', 'userID2'],\n    ignoreAdmins: false,\n    violationMessage: `Repeated messages detected. Please refrain from spamming.`,\n    maxMessages: 5,\n    timeThreshold: 5000,\n}\n\nasync function handleViolation(messageId, channelId, violationMessage) {\n    await deleteMessage(channelId, messageId)\n    await sendMessage(channelId, { content: violationMessage.toString() })\n}\n\n// Check if a message should be ignored in the first place\nif (\n    config.ignoredChannels.includes(channel.id) ||\n    config.ignoredMembers.includes(member.user.id) ||\n    (config.ignoreAdmins && member.permissions.includes('ADMINISTRATOR'))\n) {\n    return\n}\n\n// Retrieve the user's message history\nconst userKey = `${guild.id}.${member.user.id}.plugins.examod`\nconst userMessages = (await getValue(`${userKey}.messages`)) || []\nconst consecutiveRepeatedCount =\n    (await getValue(`${userKey}.consecutiveRepeatedCount`)) || 0\n\n// Get the current timestamp\nconst currentTimestamp = message.createdTimestamp\n\n// Filter messages within the time threshold\nconst recentMessages = userMessages.filter((msg) => {\n    return currentTimestamp - msg.timestamp < config.timeThreshold\n})\n\n// Check if the current message is repeated by comparing with the last message in the history\nconst isRepeated =\n    userMessages.length > 0 &&\n    userMessages[userMessages.length - 1].content === message.content\n\n// If the message is repeated, increment the count\nif (isRepeated) {\n    await setValue(\n        `${userKey}.consecutiveRepeatedCount`,\n        consecutiveRepeatedCount + 1\n    )\n\n    // If the count exceeds the limit, take action\n    if (consecutiveRepeatedCount >= config.maxMessages) {\n        await handleViolation(message.id, channel.id, config.violationMessage)\n\n        // Clear the user's message history and reset the count\n        await setValue(`${userKey}.messages`, [])\n        await deleteValue(`${userKey}.consecutiveRepeatedCount`)\n    }\n\n    return\n}\n\n// If the current message is not repeated, reset the count\nawait deleteValue(`${userKey}.consecutiveRepeatedCount`)\n\n// Update the user's message history with the current message\nuserMessages.push({\n    content: message.content,\n    timestamp: currentTimestamp,\n})\n\n// Check if the array size exceeds maxMessages and there are no consecutive repeated messages and no violations\nif (\n    userMessages.length > config.maxMessages &&\n    consecutiveRepeatedCount === 0\n) {\n    // Remove the oldest messages to keep the array within the limit\n    const messagesToRemove = userMessages.length - config.maxMessages\n    userMessages.splice(0, messagesToRemove)\n\n    // Update the user's message history with the cleaned array\n    await setValue(`${userKey}.messages`, userMessages)\n} else {\n    // Store the updated message history\n    await setValue(`${userKey}.messages`, userMessages)\n}\n"}}}]}